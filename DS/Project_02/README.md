# 여행 일정 관리 프로그램

## 1. Instroduction

    이번 프로젝트는 여행 일정 관리 시스템으로 사용자가 등록한 지역 및 도시 정보를 이용하여
    도시간의 이동 거리가 최소가 되도록 여행 일정을 설계 해주는 프로젝트이다.
    본 프로젝트는 지정된 자료구조와 그래프를 활용하여 여행 일정 관리 시스템을 구축한다. 도
    시 정보는 도시의 이름을 기준으로 하여 AVL tree에 저장하고 Graph를 이용하여 최단 거리를
     가지는 여행 일정 그래프를 설계한다. AVL tree는 전체 정보 출력 즉 프린트 기능과 저장된
    특정 정보를 삭제 및 검색하는 기능을 제공한다. Graph는 AVL tree에 저장된 도시 정보를 이
    용하여 최단 이동 거리 그래프를 MST(minimum spanning tree)를 구축하고 karuskal 알고리즘
    을 이용하여 구현한다.

## 2. . Algorithm


### 2.1 LOAD()

    LOAD 명령어는 여행 일정 관리 시스템에 도시들의 정보를 불러오는 명령어이다. 도시 정보
    가 저장 되어있는 city_list 텍스트 파일을 읽어 AVL tree를 구현하다. 또한 범위가 맞지 않는
    도시 위치 정보의 입력, 영어가 아닌 도시 및 나라이름이 들어오는 경우는 없다고 가정한다.
    중복된 위치 정보를 입력하는 경우 위치 정보/ 도시이름/ 나라이름 개의 데이터 중 하나라도
    입력하지 않은 경우는 없다고 가정하며 텍스트 파일이 없고 트리가 이미 구성되어 있는 경우
    log파일에 에러코드 100을 출력한다.Load 함수는 먼저 line을 string 형태로 받아서 city list텍스트 파일을     연후 만약 열지못하면
    false를 반환한다. 만약 avl트리의 루트가 비어있지 않아도 false를 반환한다. 반복문을 통해
    한 줄 씩 읽으며 strtok로 탭을 기준으로 잘라준다. 잘라준 글자를 city num/ city name/ coun
    name에 넣어준다. 그리고 데이터 노드를 만들어서 데이터를 저장해주고 노드를 만들어서 avl
    트리에 삽입해준다. 삽입 함수는 2) INSERT 함수와 같다.

### 2.2 INSERT()

    INSERT 명령어는 존재하는 AVL tree에 새로운 도시를 입력하는 명령어로 예외처리는 없다고
    가정하며 이미 구축된 AVL tree가 없는 경우 log 파일에 에러코드 200을 출력한다.
    맨 처음으로 만약 루트가 없다면 들어온 노드를 루트로 지정해준다.
    Insert 함수는 인자가 city data형태로서 반복문을 돌면서 위치에 맞는 곳에 삽입을 하게 된다.
    맨 처음은 bf가 0이 아닐 경우는 양쪽 자식이 같은 높이를 가지고 있는 형태이거나 리프 노
    드일 경우로 만약 0이 아니면 인자로 받은 노드의 이름과 p 값의 이름과 비교 후 삽입해준
    다. 이런 식으로 루트를 타고 계속해서 노드의 이름과 비교 후 들어온 노드가 있는 값보다 작다
    면 왼쪽으로 크다면 오른쪽으로 가게 끔 자리를 배치해준다. 트리의 밸런스가 무너졌는지 확인한다.
    D==1은 밸런스가 무너졌다면 밸런싱을 해주는 코드다. 맨 처음엔 LL의 경우로서 밸런스가
    맞지 않는 경우로 왼쪽->왼쪽으로 치우쳐져 있는 형태다. 각 노드에 데이터를 삽입 후 서
    브 트리에 b의 값을 넣어준다. else경우엔 LR의 경우이고 왼쪽으로 그리고 오른쪽으로 치우
    쳐져 있는 형태다. 루트를 기준으로 왼쪽의 서브트리의 높이가 더 높다. C의 bf를 받아서
    case문으로 bf가 0일경우,1일경우,-1일경우 분류해준다. 그리고 c가 서브트리의 새로운 루트
    가 되며 코드가 끝이 난다. 다음은 RR의 경우로 만약 b의 bf가 -1이면 각 노드에 데이터를 삽입하고 서브트리 루트에b의 값을 삽입해준다.
    이경우는 오른쪽->오른쪽으로 치우쳐져 있는 형태로 루트 기준으로
    오른쪽 서브트리의 높이가 더 높을 경우다. Else의 경우엔 RL의 경우로 오른쪽->왼쪽으로
    기울어져 있는 경우다. C의 bf를 구한 후 0,-1,1,의 경우를 고려하여 case문을 수행한다. 그
    리고 RR과RL이 끝나고 c의 bf를 0으로 맞춰주고 코드가 끝난다.
    
### 2.3 PRINT_AVL()

    PRINT_AVL 명령어는 AVL tree를 탐색하여 저장되어 있는 모든 정보를 출력하는 명령어로 log
    텍스트 파일에 도시 이름의 오름차순으로 출력한다. 만약 AVL tree에 저장돼 있는 정보가 없
    을 경우 log파일에 에러코드 300을 출력하다. 프린트 함수의 경우 스택을 이용한 inorder를 구현하여 출력해주었다. 먼저 스택을 선언하고 a를 루트로 잡는다. 만약 a가 NULL이면 에러코드를 호출한다. 반복문을 돌면서 루트의 왼쪽 값들을 push로 스택에 넣어준다. 그후 만약 스택이 비어있으면 반복문을 종료하고 아니면 a의 값에 스택에 들어간 가장 마지막 값을 넣어주고 출력해준다. 이 작업을 다하고 a는 오른쪽으로 더 이상 오른쪽이 없을 때지 움직이며 스택에 넣고 이 작업을 반복하여 출력한다.
    
### 2.4 DELETE_AVL()

    DELETE_AVL 명령어는 AVL tree를 탐색하여 저장돼 있는 모든 정보 중에 입력 받은 도시 위
    치정보를 가지고 있는 노드를 삭제하며 도시 정보를 삭제한 후 AVL tree는 다시 밸런싱 돼야
    한다. AVL tree에 해당 도시 위치 정보가 없을 경우, log.txt에 에러 코드 400을 출력한다.
    삭제의 경우 전체적인 알고리즘은 우선 반복문을 돌면서 트리의 노드들의 값과 인자로 받은
    노드의 값과 비교 후 삭제할 노드를 찾고 지워준 후 BST처럼 자식과 부모를 이어준다. 만약
    삭제 후 트리의 밸런싱이 맞지 않으면 밸런싱을 해준다. 먼저 위 코드는 트리를 돌면서 삭제
    할 노드를 찾는 과정이다. 
    삭제를 완료하고 다시 트리의 루트를 호출하여 루트의 bf를 구하였을 때 만약 1보다 크거나
    -1보다 작다면 밸런스가 무너진 것으로 각각 맞는 타입의 함수를 호출해준다. (LL,LR,RR,RL) 그
    리고 반환한 노드를 트리의 루트 노드로 삽입해준다.
    맨위에서부터 RR/ LL / LR / RL 타입이다. RR과 LL은 좌 혹은 우로 트리를 돌린 후에 루트를 반
    환하지만 RL과 LR은 트리를 돌리고 RR 혹은 LL을 다시 호출하여 재정리를 해준 뒤 값을 반
    환한다.

### 2.5 SEARCH_AVL()

    SEARCH_AVL 명령어는 입력 받은 도시의 위치정보를 가진 도시 정보의 데이터를 검색하는
    명령어로 해당 도시 위치 정보를 가진 노드를 AVL tree에서 검색 하여 도시정보를 log 텍스
    트 파일에 출력한다. 다른 예외처리는 없다고 가정하며 입력은 숫자 형태이다 만약 입력한
    정보의 데이터가 존재하지 않거나 위치 정보를 입력하지 않은 경우 log에 에러코드 500을 출
    력한다.
    다음은 노드를 검색하는 코드이다. 먼저 전역변수로 선언한 num에 명령어에서 잘라온 두 번
    째 인자를 atoi로 숫자로 변환하여 넣는다. 만약 인자가 없다면 에러코드를 호출한다. 그리고
    인오더로 트리를 돌면서 하나하나 씩 값을 비교하고 인자의 값과 일치하는 노드를 찾아 출력
    해준다.

### 2.6 BULID_GP()

    BUILD_GP 명령어는 AVL tree에 저장 되어있는 도시 정보들을 이용하여 완전 연결 gragp로
    만들고 이미 만들어진 그래프가 있는 경우 지우고 다시 생성한다. 도시 정보들의 그래프 노
    드 번호는 도시 이름의 오름 차순으로 설정한다. 만약 AVL tree에 도시 정보가 없는 경우 log
    텍스트 파일에 에러코드 600을 출력한다.
    따로 만들어둔 gp_arry에 노드들을 넣고 temp를 만들어 name기준으로 비교한 후 오름차순으로 삽입한다.
    그리고 vertex와 mList에 각각 데이터를 넣어준다.


### 2.7 PRINT_GP()

    PRINT_GP 명령어는 그래프를 탐색하여 저장 되어있는 모든 정보를 출력하는 명령어로 log
    텍스트 파일 그래프 연결 형태를 행렬 형식으로 출력한다. 이떄 행과 열 번호는 노드 번호의
    오름차순이다. 만약 그래프에 저장되어 있는 정보가 없는 경우, log텍스트 파일에 에러코드
    700을 출력한다.
    mList에 값을 넣고 이중 포문을 돌면서 노드끼리의 차를 abs로 절대값을 씌워 선언해
    둔 weight 변수에 넣고 출력한다


### 2.8 BUILD_MST()

    BUILD_MST 명령어는 존재하는 그래프의 정보를 이용하여 최적의 간선 가중치로 모든 노드
    가 연결 되어있는 tree를 생성한다. 이때 생성하는 알고리즘은 kruskal을 사용하며 이미 만들
    어진 mst가 있는 경우 지우고 다시 생성한다. 만약 그래프에 저장되어 있는 정보가 없는 경
    우 log 텍스트 파일에 에러코드 800을 출력한다.
    다음은 본인이 따로 선언한 sturct의 헤더파일의 코드이다. edge라는 구조체를 만들어 안에
    u,v는 각각의 정점이 될 변수이고 data1은 u의 데이터 data2는 v의 데이터이다 그리고 wei는
    두 데이터의 가중치다 operator는 나중에 wei를(가중치) 기준으로 sort를 해주기 위해 선언해
    주었다.
    구조체의 변수를 선언하고 각각 변수에 노드들의 정보를 넣는다. 그후 vector 형태인 kru_tree
    에도 값을 넣고 가중치를 기준으로 정렬해준다. 그리고 부모 배열에 부모가 될 벨류를 넣고
    find함수를 호출하여 이 노드들이 0이 아니면 조건에 해당되어 mst의 간선 및 정점으로 채택
    되어 MST의 결과값을 넣는 벡터형태인 r_tree에 넣는다. 다음은 find의 코드다.
    처음에 부모의 값과 두 정점의 숫자를 인자로 받아 make_set해준다. 만약 x와 y가 같으면 1
    로 반환하고 아니면 0으로 반환한다.
    부모 배열에 a를 비교하여 맞으면 a를 반환한다. 그리고 재귀적으로 이 값을 호출하여 간선
    들이 싸이클을 이루지 않는 정점이 나올 때 까지 찾는다.
    다음은 합치는 부분인다. 만약 x와 y를 set해서 y가 더 크면 x를 집어넣어 합쳐주고 아니면 x
    에 y를 넣어 합쳐준다.

### 2.9 PRINT_MST()

    PIRINT_MST 명령어는 MST를 탐색하여 저장되어 있는 모든 정보를 출력하는 명령어로 log
    텍스트 파일에 도시 정보 노드의 연결 순서대로 출력한 뒤 최종 간선들의 합을 출력한다. 만
    약 MST에 저장되어 있는 정보가 없을 경우, log 텍스트 파일에 에러코드 900을 출력한다.
    구현한 MST의 값들을 출력해주는 함수로 채택된 간선들의 집합인 백터 형태의 R_tree의 값
    들을 출력해준다. 그리고 가중치들의 합들도 출력해준다.

### 2.10 EXIT()

    EXIT 명령어는 프로그램을 종료하는 명령어로 이 명령어가 들어오면 모든 작업을 멈추고 프
    로그램을 종료한다.


## 3. RESULT

    맨처음에 LOAD를 하고 트리를 구현한 후 다시 한번 LOAD
    를 불러 값이 들어갔는지 확인한후 AVL 트리를 출력 한다. 그 후 값을 추가하고 검색, 삭제
    를 거친 후 다시 한번 PRINT해준다. 이 노드들로 그래프를 만들고 출력 후 MST를 빌드 하고
    출력하는 것으로 시험했다. MAKE를 해주고 프로그램을 수행하면 정상적으로 실행되고 log.txt가 생긴 것을
    환인 할 수 있다.
    맨 처음 LOAD는 성공하고 두 번째 LOAD는 이미 트리가 존재하기 때문에 에러코드가 발생
    한다. 그리고 AVL트리를 출력 된 모습이고 insert 값인 7423,Damm,korea를 넣고 2132의 위
    치 노드를 가진 도쿄 노드를 찾아 출력한다. 그리고 2132를 지우고 다시 AVL을 출력하였을
    때 도쿄는 없고 7423,Damm,korea가 들어간 것을 확인 할 수 있다. 그리고 그래프를 빌드하
    는 것에 성공하고 프린트 했을 때 행과 열이 같은 값으로 가지는 것을 알 수 있고 방향성이
    없는 그래프의 특징인 대각선으로 0값을 갖는 것을 확인 할 수 있다.
    그리고 MST를 빌드하고 출력한 결과이다. 모든 간선들이 들어 간 모습이고 도시들의 가중치
    또한 더한 값이 잘 출력된 모습이다.

## 4. Consideration

    이번 프로젝트는 1차 과제 보다 난이도가 높았다. 먼저 AVL의 밸런스를 맞춰주는 것이 난이
    도가 있었고 RR,LLRL,LR의 개념을 확실하게 잡지 않는다면 이번 프로젝트를 수행 할 수 없었
    을 것이다. 처음에 RR이 오른쪽으로 회전하는 것인 줄 알고 인터넷에서 공부하던 중 많은 의
    문이 달렸고 코드 구현에도 어려움이 있었지만 제대로 개념을 잡고 코드를 수행하니 수월하
    게 하였다. 삽입은 강의자료대로 하였지만 삭제는 BST의 삭제처럼 하고 그 뒤에 밸런싱 해주
    는 함수를 따로 만들어서 하였다. 이렇게 할 줄 알았으면 삽입도 이렇게 할 걸 그랬다…그리
    고 그래프와 kruskal알고리즘도 어렵지 않았지만 linux에서 돌아가지 않아 정말 애를 많이 먹
    었다. 디버깅을 하여도 원인 모르는 에러가 자꾸 뜨지만 비쥬얼 스튜디오에선 정상적으로 동
    작하였고 정말 예민한 프로그램인 것 같다. 코드를 고치는 와중에 아예 방향성을 잃어버려
    부랴부랴 다시 구현한 함수도 있었다. 여러모로 힘든 프로젝트였다. 그리고 이번에 구조체의
    operation을 선언하여 정렬하는 부분도 새롭게 배웠고 간단하게나마 벡터도 활용하였다. 다양
    한 함수를 사용하여 뿌듯하다.
